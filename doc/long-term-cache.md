
# Long term cache

Long term caching of endpoints is adapted to static or server side sites with a moderate number of data entries, eg. blog posts, products, services, showcases, etc…

It can be enabled by defining `options.hash`. When `true`, JSON endpoints files will be created using a content based hash in their filename.

Activating the options will generate a `manifest.json` file to load on first page load, that contains a hash tree mapping each endpoint name to its hash. It's similar as the Webpack manifest, but its size should be watched as there might be a lot more API entries than JS/CSS/… files to load.

When rendering server side, `api-endpoints.json` should either be:

- `require`d or `import`ed in the server `render.js` script, inlined as a global variable (eg. `window.__API__` or `window.__INITIAL_STATE__`) in the response, eventually loaded, managed, and read by a state management library (Redux, MobX, Angular, etc…), and cached client side using `sessionStorage`, `localStorage`, or `AppCache`

- `import`ed in the client app in a `service/api.js` module, and loaded either on page load or on demand, ie. using either `import` or `import()`, ie. by bundling it with other JS entries or with async (normal) chunks

**Example using Redux:**

```js
    const { list, page, slug } = requestArgs
    const { categories, entities, indexes } = reduxStore.getState().apiManifest

    const categories = fetch(categories).then(response => response.json())
    const entities = fetch(indexes[list][page]).then(response => response.json())
    const entity = fetch(entities[slug]).then(response => response.json())
```

**Example using `service/api.js` (static import):**

```js

    import api from './manifest.json' // Generated by markdown-api

    /**
     * get :: Query -> FetchInit -> Promise Error Response
     *
     * Query => { type: EntityType, slug?: EntitySlug, list?: IndexName, page?: Number }
     */
    const get = (query, initFetch) => {
        let path
        if (query.type === 'categories') {
            path = `${api['categories']}`
        } else if (query.list) {
            path = `${api[type].indexes[list][page]}`
        } else if (query.slug) {
            path = `${api[type].entities[slug]}`
        } else if (!path) {
            throw Error('Unable to construct API path to fetch')
        }
        return fetch(path, initFetch).then(response => reponse.json())
    }
```

## Versioning

If `options.subVersion` is also `true` and if the corresponding entry has been updated, the previous version of its endpoint will not be removed. This feature might be used to check differences between updates, like in a Github repository.

**Note:** you can also version control only source files, host them on Github, fetch diffs using its API, and render source/processed content client side.
