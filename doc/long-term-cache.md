
# Long term cache

Long term caching of endpoints is adapted to static or server side sites with a moderate number of entries.

It can be enabled by defining `options.hash`. When `true`, JSON endpoints files will be created using a hash in their filename, based on their content. It will also output a manifest named `api-endpoints.json`, ie. a hash tree mapping each endpoint name to its hash, similar as the Webpack manifest.

When rendering server side, `api-endpoints.json` should either be:

- `require`d or `import`ed in the server `render.js` script, inlined as a global variable (eg. `window.__API__` or `window.__INITIAL_STATE__`) in the response, eventually loaded, managed, and read by a state management library, and cached client side using `sessionStorage`, `localStorage`, or `AppCache`

- `import`ed in the client app in a `service/api.js` module, and loaded either on page load or on demand, ie. using either `import` or `import()`, ie. by bundling it with other JS entries or with async (normal) chunks

`api-endpoints.json` size should be watched as there might be a lot more API entries than JS/CSS/... files to load.

## Versioning

If `options.subVersion` is also `true` and if the correspondy entry has been updated, the previous version of its endpoint will not be removed, as well as the versions of indexes endpoints referencing it. This feature might be used to check differences between updates, like in a Github repository.

**Note:** you can also version control only source files, host them on Github, fetch diffs using its API, and render source/processed content client side.

## Example using Redux

```js
    const { list, page, slug } = requestArgs
    const { categories, entities, indexes } = reduxStore.getState().apiManifest

    const categories = fetch(categories).then(response => response.json())
    const entities = fetch(indexes[list][page]).then(response => response.json())
    const entity = fetch(entities[slug]).then(response => response.json())
```

## Example using `service/api.js` (static import):

```js

    import api from './api-endpoints.json' // Generated by markdown-api

    /**
     * get :: Query -> FetchInit -> Promise Error Response
     *
     * Query => { type: EntityType, slug?: EntitySlug, list?: IndexName, page?: Number }
     */
    const get = (query, initFetch) => {
        let path
        if (query.type === 'categories') {
            path = `${api['categories']}`
        } else if (query.list) {
            path = `${api[type].indexes[list][page]}`
        } else if (query.slug) {
            path = `${api[type].entities[slug]}`
        } else if (!path) {
            throw Error('Unable to construct API path to fetch')
        }
        return fetch(path, initFetch).then(response => reponse.json())
    }
```
